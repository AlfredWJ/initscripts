#!/bin/sh
#
# /etc/rc.d/rc.sysinit - run once at boot time
#
# Taken in part from Miquel van Smoorenburg's bcheckrc.
#

# Rerun ourselves through initlog
if [ -z "$IN_INITLOG" ]; then
 [ -f /sbin/initlog ] && exec /sbin/initlog $INITLOG_ARGS -r /etc/rc.d/rc.sysinit
fi

# Set the path
PATH=/bin:/sbin:/usr/bin:/usr/sbin
export PATH

# Read in config data.
if [ -f /etc/sysconfig/network ]; then
    . /etc/sysconfig/network
else
    NETWORKING=no
    HOSTNAME=localhost
fi

# Source functions
. /etc/rc.d/init.d/functions

# Fix console loglevel
/sbin/loglevel $LOGLEVEL

# Set the system clock.
ARC=0
SRM=0
UTC=0
if [ -f /etc/sysconfig/clock ]; then
   . /etc/sysconfig/clock

   # convert old style clock config to new values
   if [ "${CLOCKMODE}" = "GMT" ]; then
      UTC=true
   elif [ "${CLOCKMODE}" = "ARC" ]; then
      ARC=true
   fi
fi

CLOCKDEF=""
if [ -x /sbin/hwclock ]; then
   CLOCKFLAGS="--hctosys"
   CLOCK=/sbin/hwclock
else
   CLOCKFLAGS="-a"
   CLOCK=/sbin/clock
fi

case "$UTC" in
   yes|true)
    CLOCKFLAGS="$CLOCKFLAGS -u";
    CLOCKDEF="$CLOCKDEF (utc)";
  ;;
esac

if [ "$CLOCK" = "/sbin/clock" ]; then
   case "$ARC" in
     yes|true)
     	CLOCKFLAGS="$CLOCKFLAGS -A";
     	CLOCKDEF="$CLOCKDEF (arc)";
     ;;
   esac
   case "$SRM" in
     yes|true)
	CLOCKFLAGS="$CLOCKFLAGS -S";
	CLOCKDEF="$CLOCKDEF (srm)";
     ;;
   esac
fi

$CLOCK $CLOCKFLAGS

action "Setting clock $CLOCKDEF: `date`" date

# Load keymap
KEYMAP=
if [ -f /etc/sysconfig/console/default.kmap ]; then
  KEYMAP=/etc/sysconfig/console/default.kmap
else
  . /etc/sysconfig/keyboard
  if [ -n "$KEYTABLE" -a -d "/usr/lib/kbd/keymaps" ]; then
     KEYMAP=$KEYTABLE
  fi
fi
if [ -n "$KEYMAP" ]; then 
  # Since this takes in/output from stdin/out, we can't use initlog
  echo -n "Loading default keymap"
  loadkeys $KEYMAP < /dev/tty0 > /dev/tty0 2>/dev/null && \
     success "Loading default keymap" || failure "Loading default keymap"
  echo
fi   

# Load system font
if [ -x /sbin/setsysfont ]; then
    . /etc/sysconfig/i18n
    if [ -f /etc/sysconfig/console/$SYSFONT.psf.gz -o -f /usr/lib/kbd/consolefonts/$SYSFONT.psf.gz ]; then
       action "Setting default font" /sbin/setsysfont
    fi
fi

# Start up swapping.
action "Activating swap partitions" swapon -a

# Set the hostname.
action "Setting hostname ${HOSTNAME}" hostname ${HOSTNAME}

# Set the NIS domain name
if [ -n "$NISDOMAIN" ]; then
    action "Setting NIS domain name $NISDOMAIN" domainname $NISDOMAIN
else
    domainname ""
fi

if [ -f /fsckoptions ]; then
	fsckoptions=`cat /fsckoptions`
    else
	fsckoptions=
fi

if [ -f /forcefsck ]; then
	fsckoptions="-f $fsckoptions"
fi

_RUN_QUOTACHECK=0
if [ ! -f /fastboot ]; then
        STRING="Checking root filesystem"
	echo $STRING
	initlog -c "fsck  -T -a $fsckoptions /"
	rc=$?
	
	if [ "$rc" = "0" ]; then
		success "$STRING"
		echo
	elif [ "$rc" = "1" ]; then
	        passed "$STRING"
		echo
        fi
	
        # A return of 2 or higher means there were serious problems.
	if [ $rc -gt 1 ]; then
		failure "$STRING"
		echo
		echo
		echo "*** An error occurred during the file system check."
		echo "*** Dropping you to a shell; the system will reboot"
		echo "*** when you leave the shell."

		PS1="(Repair filesystem) \#"; export PS1
		sulogin

		echo "Unmounting file systems"
		umount -a
		mount -n -o remount,ro /
		echo "Automatic reboot in progress."
		reboot
	elif [ "$rc" = "1" ]; then
		_RUN_QUOTACHECK=1
	fi
fi

# check for arguments 

mount -t proc /proc /proc

if grep -i nopnp /proc/cmdline >/dev/null ; then
    PNP=
else
    PNP=yes
fi

# set up pnp 
if [ -x /sbin/isapnp -a -f /etc/isapnp.conf ]; then
    if [ -n "$PNP" ]; then
	action "Setting up ISA PNP devices" /sbin/isapnp /etc/isapnp.conf
    else
	action "Skipping ISA PNP configuration at users request" /bin/true
    fi
fi

# Remount the root filesystem read-write.
action "Remounting root filesystem in read-write mode" mount -n -o remount,rw /

# Update quotas if fsck was run on /.
if [ X"$_RUN_QUOTACHECK" = X1 -a -x /sbin/quotacheck ]; then
	action "Checking root filesystem quotas"  /sbin/quotacheck -v /
fi

# XXX Disabled to avoid complaints on root later with quotaon -a
#if [ -x /sbin/quotaon ]; then
#    action "Turning on user and group quotas for root filesystem"  /sbin/quotaon /
#fi

# The root filesystem is now read-write, so we can now log via syslog() directly..
if [ -n "$IN_INITLOG" ]; then
    IN_INITLOG=
fi

if [ ! -f /etc/HOSTNAME ]; then
    echo ${HOSTNAME} > /etc/HOSTNAME
fi

# Clear mtab
>/etc/mtab

# Enter root and /proc into mtab.
mount -f /
mount -f /proc

if ! grep -i nomodules /proc/cmdline >/dev/null && [ -f /proc/ksyms ]; then
    USEMODULES=y
else
    USEMODULES=
fi

# Our modutils don't support it anymore, so we might as well remove
# the preferred link.
rm -f /lib/modules/preferred
rm -f /lib/modules/default
if [ -x /sbin/depmod -a -n "$USEMODULES" ]; then
    # Get ready for kmod if module support in the kernel
    if [ -n `uname -r | grep "-"` ]; then
       # we're using a new kernel, no preferred needed
       mver=`uname -r`
    else
       ktag="`cat /proc/version`"
       mtag=`grep -l "$ktag" /lib/modules/*/.rhkmvtag 2> /dev/null`
       if [ -n "$mtag" ]; then
          mver=`echo $mtag | sed -e 's,/lib/modules/,,' -e 's,/.rhkmvtag,,' -e 's,[       ].*$,,'`
       fi
       if [ -n "$mver" ]; then
         ln -sf /lib/modules/$mver /lib/modules/default
       fi
    fi
    [ -n "$mver" -a -f "/boot/module-info-$mver" ] && ln -sf /boot/module-info-$mver /boot/module-info
    [ -n "$mver" -a -f "/boot/System.map-$mver" ] && ln -sf /boot/System.map-$mver /boot/System.map
    if [ -L /lib/modules/default ]; then
    	action "Finding module dependencies" depmod -a default
    else
	action "Finding module dependencies" depmod -a
    fi
fi

# load sound modules
if [ -n "$USEMODULES" ]; then
   if grep -s -q "^alias sound " /etc/conf.modules ; then
      action "Loading sound module" modprobe sound
   fi
   if grep -s -q "^alias midi " /etc/conf.modules ; then
      action "Loading midi module" modprobe midi
   fi
fi

if [ -f /proc/sys/kernel/modprobe ]; then
   if [ -n "$USEMODULES" ]; then
       echo "/sbin/modprobe" > /proc/sys/kernel/modprobe
   else
       echo "" > /proc/sys/kernel/modprobe
   fi
fi

# Load modules (for backward compatibility with VARs)
if [ -f /etc/rc.d/rc.modules ]; then
	/etc/rc.d/rc.modules
fi

# Add raid devices, old style...
if [ -f /proc/mdstat -a -f /etc/raidtab -a -x /sbin/raidadd ]; then
	action "Starting up RAID devices" raidadd -a

	rc=$?

	if [ $rc = 0 ]; then
		raidrun -a
		rc=$?
	fi

	# A non-zero return means there were problems.
	if [ $rc -gt 0 ]; then
		echo
		echo
		echo "*** An error occurred during the RAID startup"
		echo "*** Dropping you to a shell; the system will reboot"
		echo "*** when you leave the shell."

		PS1="(RAID Repair) \#"; export PS1
		sulogin

		echo "Unmounting file systems"
		umount -a
		mount -n -o remount,ro /
		echo "Automatic reboot in progress."
		reboot
	fi
fi

# Check filesystems
if [ ! -f /fastboot ]; then
        STRING="Checking filesystems"
	echo $STRING
	initlog -c "fsck  -T -R -A -a $fsckoptions"
	rc=$?
        if [ "$rc" = "0" ]; then
		success "$STRING"
		echo
	elif [ "$rc" = "1" ]; then
	        passed "$STRING"
		echo
	fi

	# A return of 2 or higher means there were serious problems.
	if [ $rc -gt 1 ]; then
	        failure "$STRING"
		echo
		echo
		echo "*** An error occurred during the file system check."
		echo "*** Dropping you to a shell; the system will reboot"
		echo "*** when you leave the shell."

		PS1="(Repair filesystem) \#"; export PS1
		sulogin

		echo "Unmounting file systems"
		umount -a
		mount -n -o remount,ro /
		echo "Automatic reboot in progress."
		reboot
	elif [ "$rc" = "1" -a -x /sbin/quotacheck ]; then
		action "Checking filesystem quotas" /sbin/quotacheck -v -R -a
	fi
fi

# Mount all other filesystems (except for NFS and /proc, which is already
# mounted). Contrary to standard usage,
# filesystems are NOT unmounted in single user mode.
action "Mounting local filesystems" mount -a -t nonfs,smbfs,ncpfs,proc

if [ -x /sbin/quotaon ]; then
    action "Turning on user and group quotas for local filesystems" /sbin/quotaon -a
fi

# Clean out /etc.
rm -f /etc/mtab~ /fastboot /fsckoptions /forcefsck

# Do we need (w|u)tmpx files? We don't set them up, but the sysadmin might...
_NEED_XFILES=
[ -f /var/run/utmpx -o -f /var/log/wtmpx ] && _NEED_XFILES=1

# Clean up /var
# I'd use find, but /usr may not be mounted.
for afile in /var/lock/* /var/run/*; do
   if [ -d $afile ]; then
      rm -f $afile/*
   else
      rm -f $afile
   fi
done

# Clean up utmp/wtmp
>/var/run/utmp
touch /var/log/wtmp
chgrp utmp /var/run/utmp /var/log/wtmp
chmod 0664 /var/run/utmp /var/log/wtmp
if [ -n "$NEED_XFILES" ]; then
  >/var/run/utmpx
  touch /var/log/wtmpx
  chgrp utmp /var/run/utmpx /var/log/wtmpx
  chmod 0664 /var/run/utmpx /var/log/wtmpx
fi

# Delete X locks
rm -f /tmp/.X*-lock

# Delete Postgres sockets
rm -f /tmp/.s.PGSQL.*

# Right, now turn on swap in case we swap to files.
swapon -a >/dev/null 2>&1
action "Enabling swap space" /bin/true

# Initialize the serial ports.
if [ -f /etc/rc.d/rc.serial ]; then
	. /etc/rc.d/rc.serial
fi

# If a SCSI tape has been detected, load the st module unconditionally
# since many SCSI tapes don't deal well with st being loaded and unloaded
if [ -f /proc/scsi/scsi ] && cat /proc/scsi/scsi | grep -q 'Type:   Sequential-Access' 2>/dev/null ; then
	if cat /proc/devices | grep -qv ' 9 st' ; then
		if [ -n "$USEMODULES" ] ; then
			# Try to load the module.  If it fails, ignore it...
			insmod -p st >/dev/null 2>&1 && modprobe st >/dev/null 2>&1
		fi
	fi
fi

# Set preferred X display manager link
preferred=
if [ -f /etc/sysconfig/desktop ]; then
	if [ -n "`grep GNOME /etc/sysconfig/desktop`" ]; then
		preferred=gdm
	elif [ -n "`grep KDE /etc/sysconfig/desktop`" ]; then
		preferred=kdm
	elif [ -n "`grep AnotherLevel /etc/sysconfig/desktop`" ]; then
		preferred=xdm
	fi
fi
if [ -n "$preferred" ] && which $preferred >/dev/null 2>&1; then
	ln -snf `which $preferred` /etc/X11/prefdm 
else
        if [ ! -L /etc/X11/prefdm ]; then
		if which gdm >/dev/null 2>&1; then
			ln -snf `which gdm` /etc/X11/prefdm
		elif which kdm >/dev/null 2>&1; then
			ln -snf `which kdm` /etc/X11/prefdm
		elif which xdm >/dev/null 2>&1; then
			ln -snf `which xdm` /etc/X11/prefdm
		fi
	fi
fi

# Now that we have all of our basic modules loaded and the kernel going,
# let's dump the syslog ring somewhere so we can find it later
dmesg > /var/log/dmesg
