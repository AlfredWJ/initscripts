
#!/bin/sh
#
# functions	This file contains functions to be used by most or all
#		shell scripts in the /etc/init.d directory.
#
# Version:	@(#) /etc/init.d/functions 1.01 26-Oct-1993
#
# Author:	Miquel van Smoorenburg, <miquels@drinkel.nl.mugnet.org>
# Hacked by:    Greg Galloway and Marc Ewing
#

# First set up a default search path.
export PATH="/sbin:/usr/sbin:/bin:/usr/bin:/usr/X11R6/bin"

# Get a sane screen width
[ -z "$COLUMNS" ] && COLUMNS=80

# Read in our configuration
if [ -f /etc/sysconfig/init ]; then
    . /etc/sysconfig/init
else
    # This all seem confusing? Look in /etc/sysconfig/init,
    # or in /usr/doc/initscripts-*/sysconfig.txt
    BOOTUP=color
    RES_COL=60
    MOVE_TO_COL="echo -en \\033[300C\\033[$[${COLUMNS}-${RES_COL}]D"
    SETCOLOR_SUCCESS="echo -en \\033[1;32m"
    SETCOLOR_FAILURE="echo -en \\033[1;31m"
    SETCOLOR_WARNING="echo -en \\033[1;33m"
    SETCOLOR_NORMAL="echo -en \\033[0;39m"
    LOGLEVEL=1
fi


if [ "$BOOTUP" != "verbose" ]; then
   INITLOG_ARGS="-q"
else
   INITLOG_ARGS=
fi

# A function to start a program.
daemon() {
	# Test syntax.
	case $1 in
	    '')    echo '$0: Usage: daemon [+/-nicelevel] {program}'
	           return 1;;
	    -*|+*) nicelevel=$1
	           shift;;
	     *)    nicelevel=0;;
	esac

        # Save basename.
        base=`basename $1`

        # See if it's already running.
	pid=`pidofproc $base`
	[ -n "$pid" ] && ps h $pid >/dev/null 2>&1 && return

	# make sure it doesn't core dump anywhere; while this could mask
	# problems with the daemon, it also closes some security problems
	ulimit -c 0
	
	# Echo daemon
        [ "$BOOTUP" = "verbose" ] && echo -n " $base"

	# And start it up.
	nice -n $nicelevel initlog $INITLOG_ARGS -c "$*" && success "$base startup" || failure "$base startup"
}

# A function to stop a program.
killproc() {
	# Test syntax.
	if [ $# = 0 ]; then
		echo "Usage: killproc {program} [signal]"
		return 1
	fi

	notset=0
	# check for second arg to be kill level
	if [ "$2" != "" ] ; then
		killlevel=$2
	else
		notset=1
		killlevel="-9"
	fi

        # Save basename.
        base=`basename $1`

        # Find pid.
        pid=`pidofproc $base`

        # Kill it.
        if [ "$pid" != "" ] ; then
                [ $BOOTUP = "verbose" ] && echo -n "$base "
		if [ "$notset" = 1 ] ; then
			# TERM first, then KILL if not dead
			kill -TERM $pid && success "$base shutdown" || failure "$base shutdown"
			usleep 100000
			if ps h $pid >/dev/null 2>&1 ; then
				sleep 1
				if ps h $pid >/dev/null 2>&1 ; then
					sleep 3
					kill -KILL $pid && success "$base shutdown" || failure "$base shutdown"
				fi
			fi
		# use specified level only
		else
	                kill $killlevel $pid && success "$base shutdown" || failure "$base shutdown"
		fi
	else
	    failure "$base shutdown"
	fi

        # Remove pid file if any.
        rm -f /var/run/$base.pid
}

# A function to find the pid of a program.
pidofproc() {
	# Test syntax.
	if [ $# = 0 ] ; then
		echo "Usage: pidofproc {program}"
		return 1
	fi

	# First try "/var/run/*.pid" files
	if [ -f /var/run/$1.pid ] ; then
	        pid=`head -1 /var/run/$1.pid`
	        if [ "$pid" != "" ] ; then
	                echo $pid
	                return 0
	        fi
	fi

	# Next try "pidof"
	pid=`pidof $1`
	if [ "$pid" != "" ] ; then
	        echo $pid
	        return 0
	fi

	# Finally try to extract it from ps
	ps auxw | awk 'BEGIN { prog=ARGV[1]; ARGC=1 } 
			   { if ((prog == $11) || (("(" prog ")") == $11) ||
			   ((prog ":") == $11)) { print $2 ; exit 0 } }' $1
}
status() {
	# Test syntax.
	if [ $# = 0 ] ; then
		echo "Usage: status {program}"
		return 1
	fi

	# First try "pidof"
	pid=`pidof $1`
	if [ "$pid" != "" ] ; then
	        echo "$1 (pid $pid) is running..."
	        return 0
        else
                pid=`ps auxww Op | awk '{ if ($12 ~ /^[^[]'"$1"'/) print $2}'`
                if [ "$pid" != "" ] ; then
                        echo "$1 (pid $pid) is running..."
                        return 0
                fi
	fi

	# Next try "/var/run/*.pid" files
	if [ -f /var/run/$1.pid ] ; then
	        pid=`head -1 /var/run/$1.pid`
	        if [ "$pid" != "" ] ; then
	                echo "$1 dead but pid file exists"
	                return 1
	        fi
	fi
	# See if /var/lock/subsys/$1 exists
	if [ -f /var/lock/subsys/$1 ]; then
		echo "$1 dead but subsys locked"
		return 2
	fi
	echo "$1 is stopped"
	return 3
}

echo_success() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "[  "
  [ "$BOOTUP" = "color" ] && $SETCOLOR_SUCCESS
  echo -n "OK"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "  ]"
  return 0
}

echo_failure() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "["
  [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
  echo -n "FAILED"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "]"
  return 1
}

# Log that something succeeded
success() {
  if [ -z "$IN_INITLOG" ]; then
     initlog -n $0 -s "$1" -e 1
  else
     echo "-n $0 -s \"$1\" -e 1" >&21
  fi
  [ "$BOOTUP" != "verbose" ] && echo_success
  return 0
}

# Log that something failed
failure() {
  rc=$?
  if [ -z "$IN_INITLOG" ]; then
     initlog -n $0 -s "$1" -e 2
  else
     echo "-n $0 -s \"$1\" -e 2" >&21
  fi
  [ "$BOOTUP" != "verbose" ] && echo_failure
  return $rc
}

# Run some action. Log its output.
action() {
  STRING=$1
  echo -n "$STRING "
  shift
  if [ -z "$IN_INITLOG" ]; then
      initlog $INITLOG_ARGS -c "$*" && success "$STRING" || failure "$STRING"
      rc=$?
      echo
      return $rc
  else
      # This sucks.
      output=`$*`
      rc=$?
      if [ -n "$output" ]; then
        cmdname=`basename $1`
        initlogcmds=`echo $output | sed -e "s/^/ -n $cmdname -s \"/" | sed -e "s/$/\"/"`
        echo "$initlogcmds" >&21
      fi

      if [ $rc ]; then
	 [ "$BOOTUP" = "verbose" ] && {
	    if [ -n "$output" ]; then
	      echo
	      echo $output
	    else
	      echo
	    fi
	 }
         success "$STRING"
      else
         echo $output
         failure "$STRING"
      fi
      [ "$BOOTUP" != "verbose" ] && echo
      return $rc
  fi
}

# Confirm whether we really want to run this service
confirm() {
  echo -n "Start service $1 (Y)es/(N)o/(C)ontinue? [Y] "
  read answer
  case $answer in
    y|Y|"")
      return 0
    ;;
    c|C)
      return 2
    ;;
    n|N)
      return 1
    ;;
    *)
      confirm $1
      return $?
    ;;
    esac
}
